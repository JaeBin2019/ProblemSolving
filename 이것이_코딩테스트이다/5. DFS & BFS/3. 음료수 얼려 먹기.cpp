#include <iostream>
#include <algorithm>

using namespace std;

/*

    5-3. 음료수 얼려 먹기

    [ 문제 정리 ]
    N X M 크기의 얼음 틀이 있다. 얼음틀은 0과 1인 부분으로 나누어져 있다.
    0은 얼음 1은 칸막이를 의미한다. 찾아야하는 것은 얼음의 총 개수이다.
    0이 붙어 있는 경우 이는 하나의 얼음으로 취급하기 때문에,
    1에 의해 분열된 지역의 개수를 구하는 문제이다.




    [ 해결 방법 ]
    DFS/BFS 로 끊어진 영역의 위치를 구한다.
    배열을 돌면서, 0인 부분을 탐색하면 count 를 1 증가시키고,
    탐색 가능한 위치까지 탐색하며 탐색한 곳을 1로 수정한다.


    [ 자료형 ]
    1 <= N, M <= 1000

    5 4
    00110
    00011
    11111
    00000

    answer : 3


    14 15
    00000111100000
    11111101111110
    11011101101110
    11011101100000
    11011111111111
    11011111111100
    11000000011111
    01111111111111
    00000000011111
    01111111111000
    00011111111000
    00000001111000
    11111111110011
    11100011111111
    11100011111111

    answer : 8

    [ 시간 복잡도 ]
    N = 100,000,000 (1억) => 1초
    방문한 노드는 재방문 하지 않기 때문에, 최악의 경우 O(N X M) 이다.
    O(1000 * 1000) = O(1,000,000) => 0.001 초


*/

int N, M;
int box[1000][1000];

void dfs(int x, int y)
{
    if (x <= -1 || x >= N || y <= -1 || y >= M)
        return;

    if (box[y][x] == 0)
    {
        box[y][x] = 1;

        dfs(x + 1, y);
        dfs(x - 1, y);
        dfs(x, y + 1);
        dfs(x, y - 1);
    }
}

int main()
{
    int answer = 0;
    cin >> N >> M;

    for (int i = 0; i < M; ++i)
    {
        for (int j = 0; j < N; ++j)
        {
            // 1%d : 1자리 정수만을 읽어옴
            scanf("%1d", &box[i][j]);
        }
    }

    for (int i = 0; i < M; ++i)
    {
        for (int j = 0; j < N; ++j)
        {
            if (box[i][j] == 0)
            {
                ++answer;
                dfs(j, i);
            }
        }
    }

    cout << answer;
}
